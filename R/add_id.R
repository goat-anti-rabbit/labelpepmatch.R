#' Manually add an identification from e.g. MS/MS
#' 
#' Manually add identifications to a pepmatched object. This can both be used as an extension to mass match, or without mass matching. 
#' @author Rik Verdonck
#' @seealso \code{\link{pep.id}}, \code{\link{pep.massmatch}}
#' @param pepmatched  Input object of class \code{pepmatched}, generated by the pepmatch() or pep.id() function of this package.  
#' @param ID_vector   A character vector with the IDs of the features that get the identifications. This is the value of the first column of the "matchlist". See vignette for an example. Can also be a single character string. 
#' @param name_vector   A character vector with the same length as the ID_vector, containing the names of the peptides.    
#' @param pepseq_vector   Optional character vector with the peptide sequences of the identifications to be added.
#' @param pepmass_vector  Optional numeric vector with the precise masses of the identifications to be added. 

#' @exportClass pepmatched
#' @return An object of class \code{pepmatched} with added identifications that can serve as input to downstream labelpepmatch functions. 


add_id <-
function    ( 
             pepmatched, 
             ID_vector,
             name_vector,
             pepseq_vector,
             pepmass_vector
                            )
                                       
{
runcount=nrow(pepmatched$design)
### First some controls before we get started!
### Here we can incorporate the function to also get just normal lists of peptides identified. 
if(class(pepmatched)!="pepmatched"){stop("ERROR: input is not of class 'pepmatched'")}
if(length(ID_vector)!=length(name_vector)){stop("ERROR: ID_vector and name_vector have to be of equal length.")}
if(missing(pepseq_vector)){pepseq_vector<-rep(NA,length(ID_vector))}
if(missing(pepmass_vector)){pepmass_vector<-rep(NA,length(ID_vector))}
if(length(ID_vector)!=length(pepseq_vector)){stop("ERROR: ID_vector and pepseq_vector have to be of equal length.")}
if(length(ID_vector)!=length(pepmass_vector)){stop("ERROR: ID_vector and pepmass_vector have to be of equal length.")}


idpep  	<-NULL
for (i in 1:runcount)
{
  matchlist<-pepmatched[[i]]
  for (j in 1:length(ID_vector))  
  {
    indices<-matchlist$ID==ID_vector[j]
    if(sum(indices)==0){warning("WARNING: one or more of the names in the ID_vector were not found in one or more runs")}
    matchlist$pepID[indices]<-name_vector[j]
    matchlist$isID[indices]<-TRUE
    matchlist$pepmass[indices]<-pepmass_vector[j]
    matchlist$pepseq[indices]<-pepseq_vector[j]
  }
  matchlist$delta_m<-matchlist$pepmass-matchlist$MW
  idpep<-c(idpep,matchlist$pepID)
  pepmatched[[i]]<-matchlist
}
						

### Now idpep is just a vector with peptide names, many of which will occur multiple times.
### We now transform it into a nice little table that tells us which peptide has been found in how many runs... 
pepmatched$identified_peptides<-as.data.frame(table(idpep))



out<-pepmatched
class(out)<-"pepmatched"

return(out)

}
